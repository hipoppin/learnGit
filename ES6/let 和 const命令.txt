1.let命令	用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。(块级作用域、不存在变量提升、不允许重复声明)
			var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined。
			这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。
			为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在‘声明后’才可使用，否则报错。
			
			暂时性死区 
				ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。
				凡是在声明之前就使用这些变量，就会报错。
				总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。
				这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。
				暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
			
			不允许重复声明
				let不允许在相同作用域内，重复声明同一个变量。不能在函数内部重新声明参数。
			
				function func() {
				  let a = 10;
				  var a = 1;
				}	
				func() // 报错
				
				function func(arg) {
				  let arg;
				}
				func() // 报错

				function func(arg) {
				  {
					let arg;
				  }
				}
				func() // 不报错
				
			
				
2.块级作用域	{}
				ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。
				ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
				
3.const 命令	const声明一个只读的常量。(块级作用域、不存在变量提升、不允许重复声明)
				一旦声明，就必须立即初始化，不能留到以后赋值。
				并且常量的值不能改变，改变常量的值会报错。
				const的作用域与let命令相同：只在声明所在的‘块级作用域’内有效。
				不存在变量提升，只能在声明的位置后面使用，不可重复声明。
				
				const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。
				例：
					const foo = {};

					// 为 foo 添加一个属性，可以成功
					foo.prop = 123;
					foo.prop // 123

					// 将 foo 指向另一个对象，就会报错
					foo = {}; // TypeError: "foo" is read-only
					

	
			